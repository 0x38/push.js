{"version":3,"file":"push.min.js","sources":["../src/push/Messages.js","../src/push/Permission.js","../src/push/Util.js","../src/agents/AbstractAgent.js","../src/agents/DesktopAgent.js","../src/agents/MobileChromeAgent.js","../src/agents/MobileFirefoxAgent.js","../src/agents/MSAgent.js","../src/agents/WebKitAgent.js","../src/index.js","../src/push/Push.js"],"sourcesContent":["// @flow\nconst errorPrefix = 'PushError:';\n\nexport default {\n    errors: {\n        incompatible: `${errorPrefix} Push.js is incompatible with browser.`,\n        invalid_plugin: `${errorPrefix} plugin class missing from plugin manifest (invalid plugin). Please check the documentation.`,\n        invalid_title: `${errorPrefix} title of notification must be a string`,\n        permission_denied: `${errorPrefix} permission request declined`,\n        sw_notification_error: `${errorPrefix} could not show a ServiceWorker notification due to the following reason: `,\n        sw_registration_error: `${errorPrefix} could not register the ServiceWorker due to the following reason: `,\n        unknown_interface: `${errorPrefix} unable to create notification: unknown interface`\n    }\n};\n","// @flow\nimport type { Global } from 'types';\n\nexport default class Permission {\n    // Private members\n    _permissions: string[];\n    _win: Global;\n\n    // Public members\n    GRANTED: string;\n    DEFAULT: string;\n    DENIED: string;\n\n    constructor(win: Global) {\n        this._win = win;\n        this.GRANTED = 'granted';\n        this.DEFAULT = 'default';\n        this.DENIED = 'denied';\n        this._permissions = [this.GRANTED, this.DEFAULT, this.DENIED];\n    }\n\n    /**\n   * Requests permission for desktop notifications\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void, Promise}\n   */\n    request(onGranted: () => void, onDenied: () => void) {\n        return arguments.length > 0\n            ? this._requestWithCallback(...arguments)\n            : this._requestAsPromise();\n    }\n\n    /**\n   * Old permissions implementation deprecated in favor of a promise based one\n   * @deprecated Since V1.0.4\n   * @param {Function} onGranted - Function to execute once permission is granted\n   * @param {Function} onDenied - Function to execute once permission is denied\n   * @return {void}\n   */\n    _requestWithCallback(onGranted: () => void, onDenied: () => void) {\n        const existing = this.get();\n\n        var resolve = (result = this._win.Notification.permission) => {\n            if (typeof result === 'undefined' && this._win.webkitNotifications)\n                result = this._win.webkitNotifications.checkPermission();\n            if (result === this.GRANTED || result === 0) {\n                if (onGranted) onGranted();\n            } else if (onDenied) onDenied();\n        };\n\n        /* Permissions already set */\n        if (existing !== this.DEFAULT) {\n            resolve(existing);\n        } else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        ) {\n            /* Safari 6+, Legacy webkit browsers */\n            this._win.webkitNotifications.requestPermission(resolve);\n        } else if (\n            this._win.Notification &&\n            this._win.Notification.requestPermission\n        ) {\n            /* Chrome 23+ */\n            this._win.Notification\n                .requestPermission()\n                .then(resolve)\n                .catch(function() {\n                    if (onDenied) onDenied();\n                });\n        } else if (onGranted) {\n            /* Let the user continue by default */\n            onGranted();\n        }\n    }\n\n    /**\n   * Requests permission for desktop notifications in a promise based way\n   * @return {Promise}\n   */\n    _requestAsPromise(): Promise<void> {\n        const existing = this.get();\n\n        let isGranted = result => result === this.GRANTED || result === 0;\n\n        /* Permissions already set */\n        var hasPermissions = existing !== this.DEFAULT;\n\n        /* Safari 6+, Chrome 23+ */\n        var isModernAPI =\n            this._win.Notification && this._win.Notification.requestPermission;\n\n        /* Legacy webkit browsers */\n        var isWebkitAPI =\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission;\n\n        return new Promise((resolvePromise, rejectPromise) => {\n            var resolver = result =>\n                isGranted(result) ? resolvePromise() : rejectPromise();\n\n            if (hasPermissions) {\n                resolver(existing);\n            } else if (isWebkitAPI) {\n                this._win.webkitNotifications.requestPermission(result => {\n                    resolver(result);\n                });\n            } else if (isModernAPI) {\n                this._win.Notification\n                    .requestPermission()\n                    .then(result => {\n                        resolver(result);\n                    })\n                    .catch(rejectPromise);\n            } else resolvePromise();\n        });\n    }\n\n    /**\n   * Returns whether Push has been granted permission to run\n   * @return {Boolean}\n   */\n    has() {\n        return this.get() === this.GRANTED;\n    }\n\n    /**\n   * Gets the permission level\n   * @return {Permission} The permission level\n   */\n    get() {\n        let permission;\n\n        /* Safari 6+, Chrome 23+ */\n        if (this._win.Notification && this._win.Notification.permission)\n            permission = this._win.Notification.permission;\n        else if (\n            this._win.webkitNotifications &&\n            this._win.webkitNotifications.checkPermission\n        )\n            /* Legacy webkit browsers */\n            permission = this._permissions[\n                this._win.webkitNotifications.checkPermission()\n            ];\n        else if (navigator.mozNotification)\n            /* Firefox Mobile */\n            permission = this.GRANTED;\n        else if (this._win.external && this._win.external.msIsSiteMode)\n            /* IE9+ */\n            permission = this._win.external.msIsSiteMode()\n                ? this.GRANTED\n                : this.DEFAULT;\n        else permission = this.GRANTED;\n\n        return permission;\n    }\n}\n","// @flow\nexport default class Util {\n    static isUndefined(obj) {\n        return obj === undefined;\n    }\n\n    static isString(obj) {\n        return typeof obj === 'string';\n    }\n\n    static isFunction(obj) {\n        return obj && {}.toString.call(obj) === '[object Function]';\n    }\n\n    static isObject(obj) {\n        return typeof obj === 'object';\n    }\n\n    static objectMerge(target, source) {\n        for (var key in source) {\n            if (\n                target.hasOwnProperty(key) &&\n                this.isObject(target[key]) &&\n                this.isObject(source[key])\n            ) {\n                this.objectMerge(target[key], source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    }\n}\n","// @flow\nimport type { Global } from 'types';\n\nexport default class AbstractAgent {\n    _win: Global;\n\n    constructor(win: Global) {\n        this._win = win;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, GenericNotification, Global } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class DesktopAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.Notification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        return new this._win.Notification(title, {\n            icon:\n                Util.isString(options.icon) || Util.isUndefined(options.icon)\n                    ? options.icon\n                    : options.icon.x32,\n            body: options.body,\n            tag: options.tag,\n            requireInteraction: options.requireInteraction\n        });\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.close();\n    }\n}\n","// @flow\nimport { Util, Messages } from 'push';\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileChromeAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.navigator !== undefined &&\n            this._win.navigator.serviceWorker !== undefined\n        );\n    }\n\n    /**\n     * Returns the function body as a string\n     * @param func\n     */\n    getFunctionBody(func: () => void) {\n        const str = func.toString().match(/function[^{]+{([\\s\\S]*)}$/);\n        return typeof str !== 'undefined' && str !== null && str.length > 1\n            ? str[1]\n            : null;\n    }\n\n    /**\n     * Creates a new notification\n     * @param id                ID of notification\n     * @param title             Title of notification\n     * @param options           Options object\n     * @param serviceWorker     ServiceWorker path\n     * @param callback          Callback function\n     */\n    create(\n        id: number,\n        title: string,\n        options: PushOptions,\n        serviceWorker: string,\n        callback: (GenericNotification[]) => void\n    ) {\n        /* Register ServiceWorker */\n        this._win.navigator.serviceWorker.register(serviceWorker);\n\n        this._win.navigator.serviceWorker.ready\n            .then(registration => {\n                /* Local data the service worker will use */\n                let localData = {\n                    id: id,\n                    link: options.link,\n                    origin: document.location.href,\n                    onClick: Util.isFunction(options.onClick)\n                        ? this.getFunctionBody(options.onClick)\n                        : '',\n                    onClose: Util.isFunction(options.onClose)\n                        ? this.getFunctionBody(options.onClose)\n                        : ''\n                };\n\n                /* Merge the local data with user-provided data */\n                if (options.data !== undefined && options.data !== null)\n                    localData = Object.assign(localData, options.data);\n\n                /* Show the notification */\n                registration\n                    .showNotification(title, {\n                        icon: options.icon,\n                        body: options.body,\n                        vibrate: options.vibrate,\n                        tag: options.tag,\n                        data: localData,\n                        requireInteraction: options.requireInteraction,\n                        silent: options.silent\n                    })\n                    .then(() => {\n                        registration.getNotifications().then(notifications => {\n                            /* Send an empty message so the ServiceWorker knows who the client is */\n                            registration.active.postMessage('');\n\n                            /* Trigger callback */\n                            callback(notifications);\n                        });\n                    })\n                    .catch(function(error) {\n                        throw new Error(\n                            Messages.errors.sw_notification_error +\n                                error.message\n                        );\n                    });\n            })\n            .catch(function(error) {\n                throw new Error(\n                    Messages.errors.sw_registration_error + error.message\n                );\n            });\n    }\n\n    /**\n     * Close all notification\n     */\n    close() {\n        // Can't do this with service workers\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, PushOptions } from 'types';\n\n/**\n * Notification agent for modern desktop browsers:\n * Safari 6+, Firefox 22+, Chrome 22+, Opera 25+\n */\nexport default class MobileFirefoxAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.navigator.mozNotification !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.navigator.mozNotification.createNotification(\n            title,\n            options.body,\n            options.icon\n        );\n\n        notification.show();\n\n        return notification;\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport { Util } from 'push';\nimport type { PushOptions, Global } from 'types';\n\n/**\n * Notification agent for IE9\n */\nexport default class MSAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return (\n            this._win.external !== undefined &&\n            this._win.external.msIsSiteMode !== undefined\n        );\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        /* Clear any previous notifications */\n        this._win.external.msSiteModeClearIconOverlay();\n\n        this._win.external.msSiteModeSetIconOverlay(\n            Util.isString(options.icon) || Util.isUndefined(options.icon)\n                ? options.icon\n                : options.icon.x16,\n            title\n        );\n\n        this._win.external.msSiteModeActivate();\n\n        return null;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close() {\n        this._win.external.msSiteModeClearIconOverlay();\n    }\n}\n","// @flow\nimport { AbstractAgent } from 'agents';\nimport type { Global, GenericNotification, PushOptions } from 'types';\n\n/**\n * Notification agent for old Chrome versions (and some) Firefox\n */\nexport default class WebKitAgent extends AbstractAgent {\n    _win: Global;\n\n    /**\n     * Returns a boolean denoting support\n     * @returns {Boolean} boolean denoting whether webkit notifications are supported\n     */\n    isSupported() {\n        return this._win.webkitNotifications !== undefined;\n    }\n\n    /**\n     * Creates a new notification\n     * @param title - notification title\n     * @param options - notification options array\n     * @returns {Notification}\n     */\n    create(title: string, options: PushOptions) {\n        let notification = this._win.webkitNotifications.createNotification(\n            options.icon,\n            title,\n            options.body\n        );\n\n        notification.show();\n\n        return notification;\n    }\n\n    /**\n     * Close a given notification\n     * @param notification - notification to close\n     */\n    close(notification: GenericNotification) {\n        notification.cancel();\n    }\n}\n","// @flow\nimport { Push } from 'push';\n\nexport default new Push(typeof window !== 'undefined' ? window : global);\n","// @flow\nimport { Messages, Permission, Util } from 'push';\nimport type { PluginManifest, GenericNotification, PushOptions } from 'types';\n\n/* Import notification agents */\nimport {\n    DesktopAgent,\n    MobileChromeAgent,\n    MobileFirefoxAgent,\n    MSAgent,\n    WebKitAgent\n} from 'agents';\n\nexport default class Push {\n    // Private members\n    _agents: {\n        desktop: DesktopAgent,\n        chrome: MobileChromeAgent,\n        firefox: MobileFirefoxAgent,\n        ms: MSAgent,\n        webkit: WebKitAgent\n    };\n    _configuration: {\n        serviceWorker: string,\n        fallback: ({}) => void\n    };\n    _currentId: number;\n    _notifications: {};\n    _win: {};\n\n    // Public members\n    Permission: Permission;\n\n    constructor(win: {}) {\n        /* Private variables */\n\n        /* ID to use for new notifications */\n        this._currentId = 0;\n\n        /* Map of open notifications */\n        this._notifications = {};\n\n        /* Window object */\n        this._win = win;\n\n        /* Public variables */\n        this.Permission = new Permission(win);\n\n        /* Agents */\n        this._agents = {\n            desktop: new DesktopAgent(win),\n            chrome: new MobileChromeAgent(win),\n            firefox: new MobileFirefoxAgent(win),\n            ms: new MSAgent(win),\n            webkit: new WebKitAgent(win)\n        };\n\n        this._configuration = {\n            serviceWorker: '/serviceWorker.min.js',\n            fallback: function(payload) {}\n        };\n    }\n\n    /**\n     * Closes a notification\n     * @param id            ID of notification\n     * @returns {boolean}   denotes whether the operation was successful\n     * @private\n     */\n    _closeNotification(id: number | string) {\n        let success = true;\n        const notification = this._notifications[id];\n\n        if (notification !== undefined) {\n            success = this._removeNotification(id);\n\n            /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n            if (this._agents.desktop.isSupported())\n                this._agents.desktop.close(notification);\n            else if (this._agents.webkit.isSupported())\n                /* Legacy WebKit browsers */\n                this._agents.webkit.close(notification);\n            else if (this._agents.ms.isSupported())\n                /* IE9 */\n                this._agents.ms.close();\n            else {\n                success = false;\n                throw new Error(Messages.errors.unknown_interface);\n            }\n\n            return success;\n        }\n\n        return false;\n    }\n\n    /**\n   * Adds a notification to the global dictionary of notifications\n   * @param {Notification} notification\n   * @return {Integer} Dictionary key of the notification\n   * @private\n   */\n    _addNotification(notification: GenericNotification) {\n        const id = this._currentId;\n        this._notifications[id] = notification;\n        this._currentId++;\n        return id;\n    }\n\n    /**\n   * Removes a notification with the given ID\n   * @param  {Integer} id - Dictionary key/ID of the notification to remove\n   * @return {Boolean} boolean denoting success\n   * @private\n   */\n    _removeNotification(id: number | string) {\n        let success = false;\n\n        if (this._notifications.hasOwnProperty(id)) {\n            /* We're successful if we omit the given ID from the new array */\n            delete this._notifications[id];\n            success = true;\n        }\n\n        return success;\n    }\n\n    /**\n   * Creates the wrapper for a given notification\n   *\n   * @param {Integer} id - Dictionary key/ID of the notification\n   * @param {Map} options - Options used to create the notification\n   * @returns {Map} wrapper hashmap object\n   * @private\n   */\n    _prepareNotification(id: number, options: PushOptions) {\n        let wrapper;\n\n        /* Wrapper used to get/close notification later on */\n        wrapper = {\n            get: () => {\n                return this._notifications[id];\n            },\n\n            close: () => {\n                this._closeNotification(id);\n            }\n        };\n\n        /* Autoclose timeout */\n        if (options.timeout) {\n            setTimeout(() => {\n                wrapper.close();\n            }, options.timeout);\n        }\n\n        return wrapper;\n    }\n\n    /**\n   * Find the most recent notification from a ServiceWorker and add it to the global array\n   * @param notifications\n   * @private\n   */\n    _serviceWorkerCallback(\n        notifications: GenericNotification[],\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let id = this._addNotification(notifications[notifications.length - 1]);\n\n        /* Listen for close requests from the ServiceWorker */\n        if (navigator && navigator.serviceWorker) {\n            navigator.serviceWorker.addEventListener('message', event => {\n                const data = JSON.parse(event.data);\n\n                if (data.action === 'close' && Number.isInteger(data.id))\n                    this._removeNotification(data.id);\n            });\n\n            resolve(this._prepareNotification(id, options));\n        }\n\n        resolve(null);\n    }\n\n    /**\n   * Callback function for the 'create' method\n   * @return {void}\n   * @private\n   */\n    _createCallback(\n        title: string,\n        options: PushOptions,\n        resolve: ({} | null) => void\n    ) {\n        let notification = null;\n        let onClose;\n\n        /* Set empty settings if none are specified */\n        options = options || {};\n\n        /* onClose event handler */\n        onClose = id => {\n            /* A bit redundant, but covers the cases when close() isn't explicitly called */\n            this._removeNotification(id);\n            if (Util.isFunction(options.onClose)) {\n                options.onClose.call(this, notification);\n            }\n        };\n\n        /* Safari 6+, Firefox 22+, Chrome 22+, Opera 25+ */\n        if (this._agents.desktop.isSupported()) {\n            try {\n                /* Create a notification using the API if possible */\n                notification = this._agents.desktop.create(title, options);\n            } catch (e) {\n                const id = this._currentId;\n                const sw = this.config().serviceWorker;\n                const cb = notifications =>\n                    this._serviceWorkerCallback(\n                        notifications,\n                        options,\n                        resolve\n                    );\n                /* Create a Chrome ServiceWorker notification if it isn't supported */\n                if (this._agents.chrome.isSupported()) {\n                    this._agents.chrome.create(id, title, options, sw, cb);\n                }\n            }\n            /* Legacy WebKit browsers */\n        } else if (this._agents.webkit.isSupported())\n            notification = this._agents.webkit.create(title, options);\n        else if (this._agents.firefox.isSupported())\n            /* Firefox Mobile */\n            this._agents.firefox.create(title, options);\n        else if (this._agents.ms.isSupported())\n            /* IE9 */\n            notification = this._agents.ms.create(title, options);\n        else {\n            /* Default fallback */\n            options.title = title;\n            this.config().fallback(options);\n        }\n\n        if (notification !== null) {\n            const id = this._addNotification(notification);\n            const wrapper = this._prepareNotification(id, options);\n\n            /* Notification callbacks */\n            if (Util.isFunction(options.onShow))\n                notification.addEventListener('show', options.onShow);\n\n            if (Util.isFunction(options.onError))\n                notification.addEventListener('error', options.onError);\n\n            if (Util.isFunction(options.onClick))\n                notification.addEventListener('click', options.onClick);\n\n            notification.addEventListener('close', () => {\n                onClose(id);\n            });\n\n            notification.addEventListener('cancel', () => {\n                onClose(id);\n            });\n\n            /* Return the wrapper so the user can call close() */\n            resolve(wrapper);\n        }\n\n        /* By default, pass an empty wrapper */\n        resolve(null);\n    }\n\n    /**\n   * Creates and displays a new notification\n   * @param {Array} options\n   * @return {Promise}\n   */\n    create(title: string, options: {}): Promise<void> {\n        let promiseCallback;\n\n        /* Fail if no or an invalid title is provided */\n        if (!Util.isString(title)) {\n            throw new Error(Messages.errors.invalid_title);\n        }\n\n        /* Request permission if it isn't granted */\n        if (!this.Permission.has()) {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                this.Permission\n                    .request()\n                    .then(() => {\n                        this._createCallback(title, options, resolve);\n                    })\n                    .catch(() => {\n                        reject(Messages.errors.permission_denied);\n                    });\n            };\n        } else {\n            promiseCallback = (resolve: () => void, reject: string => void) => {\n                try {\n                    this._createCallback(title, options, resolve);\n                } catch (e) {\n                    reject(e);\n                }\n            };\n        }\n\n        return new Promise(promiseCallback);\n    }\n\n    /**\n   * Returns the notification count\n   * @return {Integer} The notification count\n   */\n    count() {\n        let count = 0;\n        let key;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key)) count++;\n\n        return count;\n    }\n\n    /**\n   * Closes a notification with the given tag\n   * @param {String} tag - Tag of the notification to close\n   * @return {Boolean} boolean denoting success\n   */\n    close(tag: string) {\n        let key, notification;\n\n        for (key in this._notifications) {\n            if (this._notifications.hasOwnProperty(key)) {\n                notification = this._notifications[key];\n\n                /* Run only if the tags match */\n                if (notification.tag === tag) {\n                    /* Call the notification's close() method */\n                    return this._closeNotification(key);\n                }\n            }\n        }\n    }\n\n    /**\n   * Clears all notifications\n   * @return {Boolean} boolean denoting whether the clear was successful in closing all notifications\n   */\n    clear() {\n        let key,\n            success = true;\n\n        for (key in this._notifications)\n            if (this._notifications.hasOwnProperty(key))\n                success = success && this._closeNotification(key);\n\n        return success;\n    }\n\n    /**\n   * Denotes whether Push is supported in the current browser\n   * @returns {boolean}\n   */\n    supported() {\n        let supported = false;\n\n        for (var agent in this._agents)\n            if (this._agents.hasOwnProperty(agent))\n                supported = supported || this._agents[agent].isSupported();\n\n        return supported;\n    }\n\n    /**\n   * Modifies settings or returns all settings if no parameter passed\n   * @param settings\n   */\n    config(settings?: {}) {\n        if (\n            typeof settings !== 'undefined' ||\n            (settings !== null && Util.isObject(settings))\n        )\n            Util.objectMerge(this._configuration, settings);\n\n        return this._configuration;\n    }\n\n    /**\n   * Copies the functions from a plugin to the main library\n   * @param plugin\n   */\n    extend(manifest: PluginManifest) {\n        var plugin,\n            Plugin,\n            hasProp = {}.hasOwnProperty;\n\n        if (!hasProp.call(manifest, 'plugin')) {\n            throw new Error(Messages.errors.invalid_plugin);\n        } else {\n            if (\n                hasProp.call(manifest, 'config') &&\n                Util.isObject(manifest.config) &&\n                manifest.config !== null\n            ) {\n                this.config(manifest.config);\n            }\n\n            Plugin = manifest.plugin;\n            plugin = new Plugin(this.config());\n\n            for (var member in plugin) {\n                if (\n                    hasProp.call(plugin, member) &&\n                    Util.isFunction(plugin[member])\n                )\n                    // $FlowFixMe\n                    this[member] = plugin[member];\n            }\n        }\n    }\n}\n"],"names":["errors","incompatible","invalid_plugin","invalid_title","permission_denied","sw_notification_error","sw_registration_error","unknown_interface","Permission","win","_win","GRANTED","DEFAULT","DENIED","_permissions","this","onGranted","onDenied","arguments","length","_requestWithCallback","_requestAsPromise","existing","get","resolve","result","_this","Notification","permission","webkitNotifications","checkPermission","requestPermission","then","catch","hasPermissions","isModernAPI","isWebkitAPI","Promise","resolvePromise","rejectPromise","resolver","_this2","isGranted","navigator","mozNotification","external","msIsSiteMode","Util","obj","undefined","toString","call","_typeof","target","source","key","hasOwnProperty","isObject","objectMerge","AbstractAgent","DesktopAgent","title","options","icon","isString","isUndefined","x32","body","tag","requireInteraction","notification","close","MobileChromeAgent","serviceWorker","func","str","match","id","callback","register","ready","registration","localData","link","origin","document","location","href","onClick","isFunction","getFunctionBody","onClose","data","Object","assign","showNotification","vibrate","silent","getNotifications","notifications","active","postMessage","error","Error","Messages","message","MobileFirefoxAgent","createNotification","show","MSAgent","msSiteModeClearIconOverlay","msSiteModeSetIconOverlay","x16","msSiteModeActivate","WebKitAgent","cancel","_currentId","_notifications","_agents","desktop","chrome","firefox","ms","webkit","_configuration","fallback","payload","success","_removeNotification","isSupported","wrapper","_closeNotification","timeout","setTimeout","_addNotification","addEventListener","event","JSON","parse","action","Number","isInteger","_prepareNotification","_this3","create","e","sw","config","_serviceWorkerCallback","onShow","onError","promiseCallback","has","reject","_this4","_createCallback","request","count","supported","agent","settings","manifest","plugin","hasProp","member","Plugin","window","global"],"mappings":"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"}